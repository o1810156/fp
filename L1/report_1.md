基礎プログラミングおよび演習レポート ＃01
学籍番号: 1810156
氏名: ** ***
ペア学籍番号・氏名(または「個人作業」): 「個人作業」
提出日付: 2018/10/9

# [課題の再掲]

## 演習3

(aは課題1Aで行ったため本レポート、課題1Bでは飛ばす。)

- b: 剰余演算子 `%` によるプログラムを実行してみる
- c: 引数 `x` の逆数 `1/x` を計算する
- d: 引数に対するべき乗を返す関数を実装する
- e: 高さと底面円の半径から円錐の体積を計算するプログラムを実装する
- f: 引数 `x` の平方根を返す関数を実装し、検証する
- g: [自由課題]: 引数 `x` の絶対値を返す関数を実装する

## 演習4

- a: 係数 `a`, `b`, `c` を与えるとその二次方程式の解を返すプログラムを実装する
- b: aで実装した関数では桁落ちが起きることを確認する
- c: 解と係数の関係を利用してaを実装しなおす
- d: cで実装しなおした関数に関して、bで起きた桁落ちが起きていないことを確認する

## 演習5

- a: 桁落ちが起きる計算をして様子を確認する
- b: 情報落ちが起きる計算をして様子を確認する
- c: 丸め誤差が起きる計算をして様子を確認する
- d: [自由課題]: Ruby言語に関してオーバーフローが起きるかを確認する

# [実施したこととその結果]・[考察]

実施した演習量が多いのでプログラムの下に考察を書いた。
また、実行結果はほとんどのコードに関して `# =>` に続くコメントアウトののちに示している。

## 演習3

### b 剰余演算子 `%` によるプログラムを実行してみる

作成したプログラム
```ruby
def q(a, b)
    return a % b
end

puts q(10, 6) # => 4
puts q(-10, 6) # => 2
```

実行結果より、マイナスに関しても剰余算が定義されていることがわかる。

### c 引数 `x` の逆数 `1/x` を計算する

```ruby
def rec(a)
    return 1/(a.to_f)
end

puts rec(5) # => 0.2
```

整数 `a` に対し、`a.to_f`ではなく`a`にすると、`a >= 2` にて `0` になってしまった。

### d 引数に対するべき乗を返す関数を実装する

#### for文を使用する方法

```ruby
def exp(x, e)
    r = 1
    for _ in 1..e do
        r *= x
    end
    return r
end

puts exp(2, 8) # => 256
puts exp(2, 6) # => 64
puts exp(2, 7) # => 128
```

#### 再帰呼び出しを使用する方法

```ruby
def exp_r(x, e)
    e -= 1
    if e > 0 then
        return x * exp_r(x, e)
    else
        return x
    end
end

puts exp_r(2, 8) # => 256
puts exp_r(2, 6) # => 64
puts exp_r(2, 7) # => 128
```

このように対象の数と指数を引数として与え、べき乗した値を返す関数を作成した。

繰り返す処理を使わない方法は思いつけなかった。
そのため指数部が整数でない場合の実装方法は今回のレポートを書いているうちには思いつけなかった。

### e 高さと底面円の半径から円錐の体積を計算するプログラムを実装する

```ruby
def cone(r, h)
    return (Math::PI * (r**2) * h)/3.0
end

puts cone(1, 1) # => 1.0471975511965976
puts cone(2, 3) # => 12.566370614359172
```

半径と高さを引数にとり、円錐の体積を返り値として返す関数を実装した。
円周率は`Math`モジュールにて定義されている組み込み定数`PI`を使用した。

これといって特筆する点はなかった。(`3.0`と浮動小数点型にすることを気を付けたぐらいか)

### f 引数 `x` の平方根を返す関数を実装し、検証する

折角なのでニュートン法で実装してみた。以下若干LaTeX記法を用いているが意図的なものである。

～ ニュートン法の原理 ～

f'(x_1) = lim_{x \arr x_1} \frac{f(x) - f(x_1)}{x - x_1} # 微分の定義

lim を一時的に無視すると

f'(x_1)(x - x1) = f(x) - f(x_1)
f(x) = f'(x_1)(x - x_1) + f(x_1)

f(x) = 0 となるxをx = x_2 とすると

f(x_2) = f'(x_1)(x_2 - x_1) + f(x_1) = 0
f'(x_1)(x_2 - x_1) = -f(x_1)
x_2 = x_1 - \frac{f(x_1)}{f'(x_1)}
x_n = x_{n-1} - \frac{f(x_{n-1})}{f'(x_{n-1})} = C

この漸化式を解くことで近似値が算出される

\sqrt{a} は関数f(x) = x^2 - a の解
f'(x) = 2x

よって漸化式は

x_n = x_{n-1} - \frac{x_{n-1}^2 - a}{2x_{n-1}}

この原理をもとに以下のように実装した。
また、ある程度の桁で四捨五入することで無限ループとなってしまうのを避けた。(accはaccuracyの略)

```ruby
def sqrt_byN(a, acc=5) # SQuare RooT by Newton method
    if a < 0 then raise ArgumentError.new(a), "複素数になります。" end
    res = a/2.0
    pre_res = -1
    while ((res*(10**acc)).floor) != ((pre_res*(10**acc)).floor) do
        pre_res = res
		res = pre_res - (pre_res**2 - a)/(2*pre_res).to_f
    end
    return ((res*(10**acc)).floor) / (10**acc).to_f
end

puts sqrt_byN(4) # => 2.0
puts sqrt_byN(2) # => 1.41421
puts sqrt_byN(2, 10) # => 1.4142135623
puts sqrt_byN(9) # => 3.0
puts sqrt_byN(7) # => 2.64575
# puts sqrt_byN(-1)
# => prac_1_3_2.rb:68:in `sqrt_byN': 複素数になります。 (ArgumentError)
#	from prac_1_3_2.rb:83:in `<main>'
```

しっかりと想定通りの挙動をした。

### g [自由課題]: 引数 `x` の絶対値を返す関数を実装する

fを用いて数学的な定義により絶対値を返す関数を書いた。
|n| = \sqrt{a^n}

```ruby
def abs(n)
    return sqrt_byN(n*n)
end

puts abs(1) # => 1.0
puts abs(-2) # => 2.0
puts abs(-1.234) # => 1.234
# puts abs(0)
# => prac_1_3_2.rb:71:in `floor': NaN (FloatDomainError)
#         from prac_1_3_2.rb:71:in `sqrt_byN'
#         from prac_1_3_2.rb:91:in `abs'
#         from prac_1_3_2.rb:97:in `<main>'
# ↑ sqrt_byNにおいて0がエッジケースであった...折角?なので残す
```

上記の方法ではエッジケースに対応できず、
このエッジケースに対応するために
if文を増やすぐらいなら(いやsqrtを修正しろよ笑)、
if文でabsを記述したほうが楽であるから、以下のように実装しなおした

```ruby
def abs(n)
    if n < 0 then
        return -n
    else
        return n
    end
end

puts abs(1) # => 1
puts abs(-2) # => 2
puts abs(-1.234) # => 1.234
puts abs(0) # => 0
```

この課題のように場合によっては数学的な手法を取らないほうがいいときがあることが観測できる。

#### おまけ: 修正後のsqrt_byN

```ruby
def sqrt_byN(a, acc=5)
    if a == 0 then return 0 end
    if a < 0 then raise ArgumentError.new(a), "複素数になります。" end
    res = a/2.0
    pre_res = -1
    while ((res*(10**acc)).floor) != ((pre_res*(10**acc)).floor) do
        pre_res = res
		res = pre_res - (pre_res**2 - a)/(2*pre_res).to_f
    end
    return ((res*(10**acc)).floor) / (10**acc).to_f
end

puts sqrt_byN(4) # => 2.0
puts sqrt_byN(2) # => 1.41421
puts sqrt_byN(2, 10) # => 1.4142135623
puts sqrt_byN(9) # => 3.0
puts sqrt_byN(7) # => 2.64575
puts sqrt_byN(0) # => 0
```

## 演習4

### a 係数 `a`, `b`, `c` を与えるとその二次方程式の解を返すプログラムを実装する

```ruby
def quadraticSol(a, b, c)
	d = b**2 - 4*a*c
    if d < 0 then raise ArgumentError, "判別式が負になりました。" end
    return [(-b + Math.sqrt(d)) / ((2*a).to_f), (-b - Math.sqrt(d)) / ((2*a).to_f)]
end

p quadraticSol(1, 2, 1) # => [-1.0, -1.0] # (x+1)^2 = 0 の解なので正解
p quadraticSol(1, 0, -1) # => [1.0, -1.0] # (x-1)(x+1) = 0 の解なので正解
#p quadraticSol(1, 2, 3)
# =>
# prac_1_4.rb:4:in `quadraticSol': 判別式が負になりました。 (ArgumentError)
#	from prac_1_4.rb:10:in `<main>'
# x^2 + 2x + 3 = 0 の解なのでエラーで正解
```

### b aで実装した関数では桁落ちが起きることを確認する

(x + h)(x + 1) = x^2 + (h + 1)x + h にてhが小さいとき、4ac ≒ 0よりb ≒ sqrt{d} となるから桁落ちが予想される。
(以下考察はコメントアウトに示している。)

```ruby
p quadraticSol(1, 1+10**(-5), 10**(-5)) # => [-1.0000000000010001e-05, -1.0] # そこまで桁落ちはひどくない
p quadraticSol(1, 1+10**(-10), 10**(-10)) # => [-1.000000082740371e-10, -1.0] # 少しひどくなってくる
p quadraticSol(1, 1+10**(-15), 10**(-15)) # => [-1.0547118733938987e-15, -1.0] # 桁落ちがはっきりとみられる
p quadraticSol(1, 1+10**(-20), 10**(-20)) # => [0.0, -1.0] # rubyの演算処理によりほぼ0とみなされてしまった。

# printfで桁を指定して出力
printf("[%.30f, %1.0f]\n", *quadraticSol(1, 1+10**(-5), 10**(-5))) # => [-0.000010000000000010000889005823, -1]
printf("[%.30f, %1.0f]\n", *quadraticSol(1, 1+10**(-10), 10**(-10))) # => [-0.000000000100000008274037099909, -1]
printf("[%.30f, %1.0f]\n", *quadraticSol(1, 1+10**(-15), 10**(-15))) # => [-0.000000000000001054711873393899, -1]
printf("[%.50f, %1.0f]\n", *quadraticSol(1, 1+10**(-20), 10**(-20))) # => [0.00000000000000000000000000000000000000000000000000, -1] # 完全に桁落ちしている。
```


### c 解と係数の関係を利用してaを実装しなおす

比較的近い値による演算を行わないために桁落ちが起きないβと、解の性質 αβ = c/a を利用して、桁落ちを回避する

```ruby
def quadraticSol_cor(a, b, c)
	d = b**2 - 4*a*c
    if d < 0 then raise ArgumentError, "判別式が負になりました。" end
    # return [(-b + Math.sqrt(d)) / ((2*a).to_f), (-b - Math.sqrt(d)) / ((2*a).to_f)]
    beta = (-b - Math.sqrt(d)) / ((2*a).to_f)
    alpha = c / (a*beta) # 解の性質より
    return [alpha, beta]
end
```

### d cで実装しなおした関数に関して、bで起きた桁落ちが起きていないことを確認する

```ruby
printf("[%.30f, %1.0f]\n", *quadraticSol_cor(1, 1+10**(-5), 10**(-5))) # => [-0.000010000000000000000818030539, -1]
printf("[%.30f, %1.0f]\n", *quadraticSol_cor(1, 1+10**(-10), 10**(-10))) # => [-0.000000000100000000000000003643, -1]
printf("[%.30f, %1.0f]\n", *quadraticSol_cor(1, 1+10**(-15), 10**(-15))) # => [-0.000000000000001000000000000000, -1]
printf("[%.30f, %1.0f]\n", *quadraticSol_cor(1, 1+10**(-20), 10**(-20))) # => [-0.000000000000000000010000000000, -1]
```

上記に示す通り酷い桁落ちは観測されなかった。

## 演習5

### a 桁落ちが起きる計算をして様子を確認する

```ruby
def kadai5a # 桁落ちを確認する。
    printf("%.10f\n", 1.12345) # => 1.1234500000 # 対照実験用
    printf("%.10f\n", 1.0) # => 1.0000000000 # 対照実験用

    # 1.12345 - 1.0
    printf("%.10f\n", 1.12345 - 1.0) # => 0.1234500000


    printf("%.20f\n", 1.1234512345) # => 1.12345123450000006216 # 対照実験用: 存在しない桁を表示させると、10進数と2進数の違いからか差を観測できる

    # 1.1234512345 - 1.12345
    printf("%.20f\n", 1.1234512345 - 1.12345) # => 0.00000123450000000247 # 対照実験よりこれは桁落ちによって生じる誤差とは言えそうにない

    printf("%.30f\n", 1.123451234512345) # => # 対照実験用

    # 1.1234512345 - 1.12345
    printf("%.30f\n", 1.123451234512345 - 1.1234512345) # => 1.123451234512345076055339632148
end

kadai5a()
```

桁落ち自体は観測できるが、**桁落ちによって生じる** 誤差はこの演算ではあまり確認できなかった。
桁落ちによって生じる誤差は演習4のような演算をさせてみたほうが確認しやすいといえる

### b 情報落ちが起きる計算をして様子を確認する

```ruby
def kadai5b # 情報落ちを確認する。
    printf("%.10f\n", 1.0 + 0.0012345) # => 1.0012345000
    puts 1.0 + 0.0012345 # => 1.0012345
    a = 1.0 + 0.0012345
    printf("%.10f\n", a) # => 1.0012345000

    printf("%.60f\n", 1.0 + 1.2345e-40) # => 1.000000000000000000000000000000000000000000000000000000000000
    puts 1.0 + 1.2345e-40 # => 1.0
    b = 1.0 + 1.2345e-40
    printf("%.60f\n", b) # => 1.000000000000000000000000000000000000000000000000000000000000
end

kadai5b()
```

ごく微量な数を足した場合、表示桁を大きくとっても足した極微少量の部分が現れないことが確認できる。
これは情報落ちといえる。

### c 丸め誤差が起きる計算をして様子を確認する

```ruby
def kadai5c # 丸め誤差を確認する。
    printf("%.30f\n", 0.1 * 0.1) # => 0.010000000000000001942890293094
    printf("%.30f\n", 0.1 / 10.0) # => 0.010000000000000000208166817117
    p((5 * 0.1) == (5/10.0)) # => true

    printf("%.30f\n", 5 * 0.125) # => 0.625000000000000000000000000000
    printf("%.30f\n", 5 / 8.0) # => 0.625000000000000000000000000000
    p((5 * 0.125) == (5/8.0)) # => true
end

kadai5c()
```

10進数を2進数に変換する演算を行ってみると、
2進数において循環小数となる10進小数が計算に誤差をもたらすと考えられる。

10進数の小数0.1(以下、n進数小数を0.1(n)のようにあらわす)

0.1(2) = 2^(-1)
0.01(2) = 2^(-2)
...
のように考えると、次のようにして0.1(10)を2進数にできる。(以下10進数)

0.1 * 2 = 0.2 # 0.
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1
0.6 * 2 = 1.2 # 1
0.2 * 2 = 0.4 # 0
0.4 * 2 = 0.8 # 0
0.8 * 2 = 1.6 # 1

上から読んで0.001100110011....の環状小数となっていることがわかる。
よって2進数では0.1を正確に保存することが難しい。
一方2進数の累乗で表せる数は上記の方法で変換した場合明らかに有限小数となる。

0.125 * 2 = 0.25 # 0.
0.25 * 2 = 0.5 # 0
0.5 * 2 = 1.0 # 1

0.125(10) = 0.01(2) ( = 2^(-3) )

これらの考察より、10進数小数では0.1のように循環小数になってしまうことによる丸め誤差を起こしうる実数が存在しうることがわかり、
逆に2の累乗で表せる数に関してはこのようなことは起こりえないといえる。

### d [自由課題]: Ruby言語に関してオーバーフローが起きるかを確認する

あまり今回の話とは関係がないが、誤差の原因とはなりうるオーバーフローについて調べた。

```ruby
a = (2**64).to_i
p a # => 18446744073709551616
p a.class # => Integer

b = (2**128).to_i
p b # => 340282366920938463463374607431768211456
p b.class # => Integer

c = (2**256).to_i
p c # => 115792089237316195423570985008687907853269984665640564039457584007913129639936
p c.class # => Integer

d = (2**512).to_i
p d # => 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096
p d.class # => Integer

e = (2**1024).to_i
p e # => 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
p e.class # => Integer

f = (2**2048).to_i
p f # => 32317006071311007300714876688669951960444102669715484032130345427524655138867890893197201411522913463688717960921898019494119559150490921095088152386448283120630877367300996091750197750389652106796057638384067568276792218642619756161838094338476170470581645852036305042887575891541065808607552399123930385521914333389668342420684974786564569494856176035326322058077805659331026192708460314150258592864177116725943603718461857357598351152301645904403697613233287231227125684710820209725157101726931323469678542580656697935045997268352998638215525166389437335543602135433229604645318478604952148193555853611059596230656
p f.class # => Integer

# 省略

g = (2**(2**20)).to_i # => すごい時間がかかった
p g

h = (2**(2**32)).to_i # エラーとなった
p h
# =>
# prac_1_5.rb:115: warning: in a**b, b may be too big
# prac_1_5.rb:115:in `to_i': Infinity (FloatDomainError)
#         from prac_1_5.rb:115:in `<main>'
```

しかしこれらの結果から、rubyにおける整数値の幅はC言語等の静的言語の整数型(-2^31 ～ 2^31)等と比べて
相当整数値の範囲が大きいことがわかる。
これは動的言語の特徴といえる。

# [アンケート]

Q1. プログラムを作るという課題はどれくらい大変でしたか?

毎日触れているので何とも、、、Rubyはあまり触れない(普段はPython3を使用している)ので言語差がある点は割と大変でしたが特に苦労はしませんでした。

Q2. コンピュータでの数値の計算に対する数学とは違う挙動についてどう思いましたか?

むしろ数学と違い挙動がはっきりしている分扱いやすい気がしています笑

Q3. リフレクション(今回の課題で分かったこと)・感想・要望をどうぞ。

途中範囲外の `if` 文や `for` 文等を使用してしまい申し訳ありませんでした(謝ることではない...?)
次回も頑張りたいと思います。