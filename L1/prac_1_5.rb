def kadai5a # 桁落ちを確認する。
    printf("%.10f\n", 1.12345) # => 1.1234500000 # 対照実験用
    printf("%.10f\n", 1.0) # => 1.0000000000 # 対照実験用

    # 1.12345 - 1.0
    printf("%.10f\n", 1.12345 - 1.0) # => 0.1234500000


    printf("%.20f\n", 1.1234512345) # => 1.12345123450000006216 # 対照実験用: 存在しない桁を表示させると、10進数と2進数の違いからか差を観測できる

    # 1.1234512345 - 1.12345
    printf("%.20f\n", 1.1234512345 - 1.12345) # => 0.00000123450000000247 # 対照実験よりこれは桁落ちによって生じる誤差とは言えそうにない

    printf("%.30f\n", 1.123451234512345) # => # 対照実験用

    # 1.1234512345 - 1.12345
    printf("%.30f\n", 1.123451234512345 - 1.1234512345) # => 1.123451234512345076055339632148
end

kadai5a()

# 桁落ち自体は観測できるが、**桁落ちによって生じる** 誤差はこの演算ではあまり確認できなかった。
# 桁落ちによって生じる誤差は演習4のような演算をさせてみたほうが確認しやすいといえる

def kadai5b # 情報落ちを確認する。
    printf("%.10f\n", 1.0 + 0.0012345) # => 1.0012345000
    puts 1.0 + 0.0012345 # => 1.0012345
    a = 1.0 + 0.0012345
    printf("%.10f\n", a) # => 1.0012345000

    printf("%.60f\n", 1.0 + 1.2345e-40) # => 1.000000000000000000000000000000000000000000000000000000000000
    puts 1.0 + 1.2345e-40 # => 1.0
    b = 1.0 + 1.2345e-40
    printf("%.60f\n", b) # => 1.000000000000000000000000000000000000000000000000000000000000
end

kadai5b()

# ごく微量な数を足した場合、表示桁を大きくとっても足した極微少量の部分が現れないことが確認できる。
# これは情報落ちといえる。

def kadai5c # 丸め誤差を確認する。
    printf("%.30f\n", 0.1 * 0.1) # => 0.010000000000000001942890293094
    printf("%.30f\n", 0.1 / 10.0) # => 0.010000000000000000208166817117
    p((5 * 0.1) == (5/10.0)) # => true

    printf("%.30f\n", 5 * 0.125) # => 0.625000000000000000000000000000
    printf("%.30f\n", 5 / 8.0) # => 0.625000000000000000000000000000
    p((5 * 0.125) == (5/8.0)) # => true
end

kadai5c()

# 10進数を2進数に変換する演算を行ってみると、
# 2進数において循環小数となる10進小数が計算に誤差をもたらすと考えられる。
#
# 10進数の小数0.1(以下、n進数小数を0.1(n)のようにあらわす)
#
# 0.1(2) = 2^(-1)
# 0.01(2) = 2^(-2)
# ...
# のように考えると、次のようにして0.1(10)を2進数にできる。(以下10進数)
#
# 0.1 * 2 = 0.2 # 0.
# 0.2 * 2 = 0.4 # 0
# 0.4 * 2 = 0.8 # 0
# 0.8 * 2 = 1.6 # 1
# 0.6 * 2 = 1.2 # 1
# 0.2 * 2 = 0.4 # 0
# 0.4 * 2 = 0.8 # 0
# 0.8 * 2 = 1.6 # 1
#
# 上から読んで0.001100110011....の環状小数となっていることがわかる。
# よって2進数では0.1を正確に保存することが難しい。
# 一方2進数の累乗で表せる数は上記の方法で変換した場合明らかに有限小数となる。
#
# 0.125 * 2 = 0.25 # 0.
# 0.25 * 2 = 0.5 # 0
# 0.5 * 2 = 1.0 # 1
#
# 0.125(10) = 0.01(2) ( = 2^(-3) )

# d
# あまり今回の話とは関係がないが、誤差の原因とはなりうるオーバーフローについて調べた。

a = (2**64).to_i
p a # => 18446744073709551616
p a.class # => Integer

b = (2**128).to_i
p b # => 340282366920938463463374607431768211456
p b.class # => Integer

c = (2**256).to_i
p c # => 115792089237316195423570985008687907853269984665640564039457584007913129639936
p c.class # => Integer

d = (2**512).to_i
p d # => 13407807929942597099574024998205846127479365820592393377723561443721764030073546976801874298166903427690031858186486050853753882811946569946433649006084096
p d.class # => Integer

e = (2**1024).to_i
p e # => 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216
p e.class # => Integer

f = (2**2048).to_i
p f # => 32317006071311007300714876688669951960444102669715484032130345427524655138867890893197201411522913463688717960921898019494119559150490921095088152386448283120630877367300996091750197750389652106796057638384067568276792218642619756161838094338476170470581645852036305042887575891541065808607552399123930385521914333389668342420684974786564569494856176035326322058077805659331026192708460314150258592864177116725943603718461857357598351152301645904403697613233287231227125684710820209725157101726931323469678542580656697935045997268352998638215525166389437335543602135433229604645318478604952148193555853611059596230656
p f.class # => Integer

# 省略

g = (2**(2**20)).to_i # => すごい時間がかかった
p g

h = (2**(2**32)).to_i # エラーとなった
p h
# =>
# prac_1_5.rb:115: warning: in a**b, b may be too big
# prac_1_5.rb:115:in `to_i': Infinity (FloatDomainError)
#         from prac_1_5.rb:115:in `<main>'

# しかしこれらの結果から、rubyにおける整数値の幅はC言語等の静的言語の整数型(-2^31 ～ 2^31)等と比べて
# 相当整数値の範囲が大きいことがわかる。
# これは動的言語の特徴といえる。