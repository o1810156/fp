# 基礎プログラミングおよび演習レポート ＃03

学籍番号: 1810156
\
氏名: ** ***
\
ペア学籍番号・氏名(または「個人作業」): 個人作業
\
提出日付: 2018/10/23

## レポートに関する注意点等(お願い)

- 今回もマークダウン記法を多用しています。
- 見やすさを考慮し本レポートと全く同じ内容を[Githubレポジトリ]()に用意しました。もし見づらいと感じられた場合はこちらからお願いします。
- 実行結果は`# =>`のコメントの後に記している場合があります。予めご了承ください。
- `~~ 省略 ~~`と記し一部実行結果を省略しています。

## [課題の再掲]

### 演習 1 fizzbuzz問題

- b: `0`から`99`までの数を順に打ち出すが、ただし`3`の倍数の時は`fizz`、`5`の倍数の時は`buzz`、`3`の倍数かつ`5`の倍数の時は`fizzbuzz`と(数値の代わりに)打ち出す。
- c: `0`から`99`までの数を順に打ち出すが、ただし`3`の倍数と`3`がつく数字の時は数値の代わりに`aho`と打ち出す。

### 演習 5 配列に関係したプログラム

- a: 数の配列を受け取り、その最大値を返す。
- b: 数の配列を受け取り、最大値が何番目かを返す。なお先頭を`0`番目とし、最大値が複数あればその最初の番号が答えであるとする。
- c: 数の配列を受け取り、最大値が何番目かを出力する。なお先頭を`0`番目とし、最大値が複数あればそれらをすべて出力する。
- d: 数の配列を受け取り、その平均より小さい要素を出力する (例: `1, 4, 5, 11` → `1, 4, 5`)。
- e: 数の配列を受け取り、その内容を「小さい順」に並べて出力する (例: `4, 11, 5, 1` → `1, 4, 5, 11`)。

### Appendix

演習2～4、6に関しては前回の内容とあまりにも酷似している(または同一である)ため、本レポートに再掲するようなことはしない。
\
しかしそれでは今回のレポートの内容が希薄となってしまうため、以下の二つについておまけとして取り組んだ。

- おまけ 1: 今回学んだ配列を使用した、行列の積を計算するプログラム 
- おまけ 2: Rubyのブロック機能を利用した第1回「ニュートン法」、第2回「数値積分」の改良

## [実施したこととその結果]

### 演習 1 fizzbuzz問題

#### b fizzbuzz

`3`の倍数、`5`の倍数、`3`の倍数かつ`5`の倍数、のそれぞれで分岐させて表示させるプログラムを作成すればよいが、
\
「`3`の倍数かつ`5`の倍数」すなわち「`15`の倍数」から比較しないと、`15`の倍数も`3`の倍数(または`5`の倍数)として拾ってしまう点に注意したい。
\
プログラムは以下のようになる。

```ruby
100.times do |i|
    if i % 15 == 0
        print("fizzbuzz\n")
    elsif i % 3 == 0
        print("fizz\n")
    elsif i % 5 == 0
        print("buzz\n")
    else
        printf("%d\n", i)
    end
end
```

実行結果↓

```
fizzbuzz
1
2
fizz
4
buzz
fizz
7
8
fizz
buzz
11
fizz
13
14
fizzbuzz
16
17
fizz
19
buzz

~~ 省略 ~~

buzz
fizz
82
83
fizz
buzz
86
fizz
88
89
fizzbuzz
91
92
fizz
94
buzz
fizz
97
98
fizz
```

#### c ナベアツ

`3のつく数`、というのは剰余算で割り出せるが、桁が大きくなっていくほどこの方法では対処できなくなる(常用対数をとり繰り返し回数を決めるという方法ならできそうではある。)。
\
なにより~~実装が面倒くさい~~可読性が悪化するので、`数値 -> 数字列(文字列) -> .include?メソッド`という方法を取って実装した。

```ruby
100.times do |i|
    if i % 3 == 0 or i.to_s.include?("3")
        printf("aho\n")
    else
        printf("%d\n", i)
    end
end
```

実行結果↓

```
aho
1
2
aho
4
5
aho
7
8
aho
10
11
aho
aho
14
aho
16
17
aho
19
20

~~ 省略 ~~

80
aho
82
aho
aho
85
86
aho
88
89
aho
91
92
aho
94
95
aho
97
98
aho
```

### 演習 5 配列に関係したプログラム

#### a 最大値

実は`Array`クラスには標準で`max`が実装されているため、以下は`arr.max`に等しい。
\
要素をループで比較していき、現在の最大値より大きい値にであったらその値を最大値にする、、としていけばよい。

```ruby
def max_in_arr(arr)
    m = arr[0]
    for elm in arr[1..-1]
        if elm > m then m = elm end
    end
    return m
end

puts "max_in_arr([0, 1, 2]) = #{max_in_arr([0, 1, 2])}"
puts "max_in_arr([1, 2, 0]) = #{max_in_arr([1, 2, 0])}"
puts "max_in_arr([2, 1, 0]) = #{max_in_arr([2, 1, 0])}"
puts "max_in_arr([0, 1, 2, 2]) = #{max_in_arr([0, 1, 2, 2])}"
# =>
# max_in_arr([0, 1, 2]) = 2
# max_in_arr([1, 2, 0]) = 2
# max_in_arr([2, 1, 0]) = 2
# max_in_arr([0, 1, 2, 2]) = 2
```

#### b 最大値のインデックス(最初のもの)

こちらに関しても既存のメソッドの組み合わせ`arr.index(arr.max)`に等しく実際は自分で実装する必要はない。
\
`each_with_index`メソッドを用いることで要素とインデックスの両方を同時に取り出せる。これを利用し、インデックスのみを記憶して最後に返すという方法を取った。比較中の最大値は`arr[ind]`で取得している。

```ruby
def index_of_max(arr)
    ind = 0
    arr.each_with_index do |elm, i|
        if elm > arr[ind] then ind = i end # 比較演算子を>=にすると最後を取ってくる
    end
    return ind
end

puts "index_of_max([0, 1, 2]) = #{index_of_max([0, 1, 2])}" # =>
puts "index_of_max([1, 2, 0]) = #{index_of_max([1, 2, 0])}" # => 
puts "index_of_max([2, 1, 0]) = #{index_of_max([2, 1, 0])}" # =>
puts "index_of_max([2, 1, 0, 2]) = #{index_of_max([2, 1, 0, 2])}" # =>
# =>
# index_of_max([0, 1, 2]) = 2
# index_of_max([1, 2, 0]) = 1
# index_of_max([2, 1, 0]) = 0
# index_of_max([2, 1, 0, 2]) = 0
```

#### c 最大値のインデックス(全て)

bと似ているものの、打って変わって既存の方法では等価なものは存在しない。
\
一度最大値を取得し(取得にはaで実装した`max_in_arr`を使用した)、大きさが一致する要素のインデックスを配列に保存して返せばよい。

```ruby
def indexs_of_max(arr)
    inds = []
    m = max_in_arr(arr) # 複数ある場合を考慮すると先に最大値を取るほうが早い
    arr.each_with_index do |elm, i|
        if elm == m then inds.push(i) end
    end
    return inds
end

puts "indexs_of_max([0, 1, 2]) = #{indexs_of_max([0, 1, 2])}" # =>
puts "indexs_of_max([1, 2, 0]) = #{indexs_of_max([1, 2, 0])}" # =>
puts "indexs_of_max([2, 1, 0]) = #{indexs_of_max([2, 1, 0])}" # =>
puts "indexs_of_max([2, 1, 0, 2]) = #{indexs_of_max([2, 1, 0, 2])}" # =>
# =>
# indexs_of_max([0, 1, 2]) = [2]
# indexs_of_max([1, 2, 0]) = [1]
# indexs_of_max([2, 1, 0]) = [0]
# indexs_of_max([2, 1, 0, 2]) = [0, 3]
```

#### d 平均より小さい要素

こちらも調べた限りでは簡単に実行する既存の方法はなさそうであった。
\
まずは合計値を算出し、平均を算出したのち、平均値と要素を比較して小さいものを配列に格納していくという方法を取った。

```ruby
def unders_of_ave(arr)
    s = 0
    for elm in arr
        s += elm
    end
    ave = s / arr.length.to_f
    unders = []
    for elm in arr
        if elm < ave then unders.push(elm) end
    end
    return unders
end

puts "unders_of_ave([1, 4, 5, 11]) = #{unders_of_ave([1, 4, 5, 11])}"
puts "unders_of_ave(Array(0..10)) = #{unders_of_ave(Array(0..10))}"
puts "unders_of_ave([1, 1, 4, 5, 1, 4]) = #{unders_of_ave([1, 1, 4, 5, 1, 4])}"
# =>
# unders_of_ave([1, 4, 5, 11]) = [1, 4, 5]
# unders_of_ave(Array(0..10)) = [0, 1, 2, 3, 4]
# unders_of_ave([1, 1, 4, 5, 1, 4]) = [1, 1, 1]
```

#### e 並べ替え(ソート)

既存の方法では`arr.sort`に等しい。
\
今回は選択ソートで実装した。(他のソートに関しては他回で言及されているので今回は取り組まなかった。)
\

選択ソートのアルゴリズムを以下に示す。

1. 配列全体を未決定領域とする。
2. 配列のうちから最も小さい要素を選ぶ。(`max_in_arr`の逆をすればよい)
3. 未決定領域の先頭と選んだ要素の位置を入れ替える。(スワップする)
4. 未決定領域の先頭を決定済みとし、残りを未決定領域とする。
5. 2～3を未決定領域がなくなるまで繰り返す。(繰り返し回数は配列の要素数である。)

例 :
()を未決定領域とする。

```
(4, 11, 5, 1) -> 1が最小。4と入れ替え決定済みとする。
1, (4, 11, 5) -> 4が最小。そのまま。
1, 4, (11, 5) -> 5が最小。11と入れ替え決定済みとする。
1, 4, 5, (11) -> 11が最小。決定済みとする。
1, 4, 5, 11
```

以下が実装である。元の配列の内容が変わってしまうことを防ぐため、始めにコピーをしている。
\
なおRubyでは`a, b = b, a`と記述することで要素をスワップできる。

```ruby
def select_sort(arr)
    res = Array.new(arr.length) {|i| arr[i]} # コピー
    # res = arr.dup # コピー
    len = res.length-1
    for i in 0..len
        for j in i+1..len
            if res[i] > res[j] then res[i], res[j] = res[j], res[i] end
        end
    end
    return res
end

puts "select_sort([4, 11, 5, 1]) = #{select_sort([4, 11, 5, 1])}"
puts "select_sort([1, 3, 0, 2]) = #{select_sort([1, 3, 0, 2])}"
puts "select_sort([1, 2, 0, 2]) = #{select_sort([1, 2, 0, 2])}"
# =>
# select_sort([4, 11, 5, 1]) = [1, 4, 5, 11]
# select_sort([1, 3, 0, 2]) = [0, 1, 2, 3]
# select_sort([1, 2, 0, 2]) = [0, 1, 2, 2]
```

### Appendix

#### おまけ 1 [行列計算の実装 1] 行列の積を求める

```
a = [[1, 2]
    ,[3, 4]]

b = [[5, 6]
    ,[7, 8]]

c = a・b

c = [[1*5+2*7, 1*6+2*8]
    ,[3*5+4*7, 3*6+4*8]]
```

という行列計算を行うdot関数を定義する。

```
関数名: dot
    引数: 行列の整合性が取れている行列2つ a b
    返り値: aとbの積
```

入力値チェックを`dot`関数内で行うのは避けたかったため、`dot`関数の引数は予め用意した`Matrix`クラスのインスタンスに限定し、機能を切り分けた。
\
演算が`a・b`であるとき`a`の列数と`b`の行数は一致している必要がある。このチェックに関しては`dot`関数内で行っている。

```ruby
class Matrix
    def initialize(arr)
        if arr.is_a?(Numeric)
            @val = [[arr]]
            @row, @col = 1, 1
        elsif arr.class == Array
            if arr[0].class == Array
                if !(arr[0][0].is_a?(Numeric)) then raise ArgumentError.new(), "Numeric please." end
                @val = arr
                @row, @col = arr.length, arr[0].length
                if arr.any? {|elm| elm.length != arr[0].length} then raise ArgumentError.new(), "Invalid col length." end
            elsif arr[0].is_a?(Numeric)
                @val = [arr]
                @row, @col = 1, arr.length
            end
        else
            raise ArgumentError.new(), "Numeric matrix please."
        end
    end

    attr_accessor :val, :row, :col
end

class InvalidCombError < StandardError; end

def dot(a, b)
    if a.class != Matrix or b.class != Matrix # 引数がMatrixクラスでない
        raise ArgumentError.new(), "Matrixs please."
    end

    if a.col != b.row # 引数の行列の数の整合性が取れていないため定義できない。
        raise InvalidCombError.new(), "a.col is not match b.row."
    end

    c = []

    a.row.times do |i|
        c.push([])
        b.col.times do |j|
            d = 0
            a.col.times do |k|
                # 積の結果は各値についてa[i行][k列] * b[k行][j列]の和であることは数学的定義に基づく。
                d += a.val[i][k]*b.val[k][j]
            end
            c[i].push(d)
        end
    end
    return Matrix.new(c)
end

a = Matrix.new([[1, 2] ,[3, 4]])
b = Matrix.new([[5, 6] ,[7, 8]])

p dot(a, b).val # => [[19, 22], [43, 50]]
p dot(b, a).val # => [[23, 34], [31, 46]]

c = Matrix.new(5)
d = Matrix.new([1, 2])

p dot(c, d).val # => [[5, 10]]

# e = Matrix.new([[1, 2], [1]]) # => Invalid col length.
```

以下この関数を使用して前期の「線形代数第一」で出題されたレポートを解かせてみた。
\
まずは定義されない値のときにそのように表示できる関数`dot_homework`を用意した。

```ruby
def dot_homework(a, b)
    begin
        puts "#{a.val}・#{b.val} = #{dot(a, b).val}"
    rescue InvalidCombError
        puts "#{a.val}・#{b.val} -> 定義されない"
    end
end
```

問題は以下のようであった。

```
問題

次の3つの行列a, b, cとその転置行列ta, tb, tcという6個の行列を考える。
この6個の行列2個を並べる並べ方は全部で6 × 6 = 36通りの組み合わせがある。
積が定義できるものは積を計算し、
積が定義されないものは、定義されないと解答欄に記入せよ。

a = [[-1, 1, 0]
    ,[3, 0, 4]]

b = [[1, 0]
    ,[-2, 1]
    ,[3, 2]]

c = [[3]
    ,[2]
    ,[-1]]
```

以下、解法である。転置行列を求めるために`Matrix`クラスを拡張した。

```ruby
a = Matrix.new([[-1, 1, 0] ,[3, 0, 4]])
b = Matrix.new([[1, 0] ,[-2, 1] ,[3, 2]])
c = Matrix.new([[3], [2], [-1]])

# 転置行列を求める関数Tの実装

class Matrix
    def T
        rw = []
        self.col.times do |i|
            cl = []
            self.row.times do |j|
                cl.push(self.val[j][i])
            end
            rw.push(cl)
        end
        return Matrix.new(rw)
    end
end

ta = a.T
tb = b.T
tc = c.T

p ta.val # => [[-1, 3], [1, 0], [0, -4]]
p tb.val # => [[1, -2, 3], [0, 1, 2]]
p tc.val # => [[3, 2, -1]]

mats = [a, b, c, ta, tb, tc]

# 以下のように書けば6 × 6 = 36通りとなる。
for m in mats
    for n in mats
        dot_homework(m, n)
    end
end
```

実行結果↓

```
[[-1, 1, 0], [3, 0, 4]]・[[-1, 1, 0], [3, 0, 4]] -> 定義されない
[[-1, 1, 0], [3, 0, 4]]・[[1, 0], [-2, 1], [3, 2]] = [[-3, 1], [15, 8]]
[[-1, 1, 0], [3, 0, 4]]・[[3], [2], [-1]] = [[-1], [5]]
[[-1, 1, 0], [3, 0, 4]]・[[-1, 3], [1, 0], [0, 4]] = [[2, -3], [-3, 25]]
[[-1, 1, 0], [3, 0, 4]]・[[1, -2, 3], [0, 1, 2]] -> 定義されない
[[-1, 1, 0], [3, 0, 4]]・[[3, 2, -1]] -> 定義されない
[[1, 0], [-2, 1], [3, 2]]・[[-1, 1, 0], [3, 0, 4]] = [[-1, 1, 0], [5, -2, 4], [3, 3, 8]]
[[1, 0], [-2, 1], [3, 2]]・[[1, 0], [-2, 1], [3, 2]] -> 定義されない
[[1, 0], [-2, 1], [3, 2]]・[[3], [2], [-1]] -> 定義されない
[[1, 0], [-2, 1], [3, 2]]・[[-1, 3], [1, 0], [0, 4]] -> 定義されない
[[1, 0], [-2, 1], [3, 2]]・[[1, -2, 3], [0, 1, 2]] = [[1, -2, 3], [-2, 5, -4], [3, -4, 13]]
[[1, 0], [-2, 1], [3, 2]]・[[3, 2, -1]] -> 定義されない
[[3], [2], [-1]]・[[-1, 1, 0], [3, 0, 4]] -> 定義されない
[[3], [2], [-1]]・[[1, 0], [-2, 1], [3, 2]] -> 定義されない
[[3], [2], [-1]]・[[3], [2], [-1]] -> 定義されない
[[3], [2], [-1]]・[[-1, 3], [1, 0], [0, 4]] -> 定義されない
[[3], [2], [-1]]・[[1, -2, 3], [0, 1, 2]] -> 定義されない
[[3], [2], [-1]]・[[3, 2, -1]] = [[9, 6, -3], [6, 4, -2], [-3, -2, 1]]
[[-1, 3], [1, 0], [0, 4]]・[[-1, 1, 0], [3, 0, 4]] = [[10, -1, 12], [-1, 1, 0], [12, 0, 16]]
[[-1, 3], [1, 0], [0, 4]]・[[1, 0], [-2, 1], [3, 2]] -> 定義されない
[[-1, 3], [1, 0], [0, 4]]・[[3], [2], [-1]] -> 定義されない
[[-1, 3], [1, 0], [0, 4]]・[[-1, 3], [1, 0], [0, 4]] -> 定義されない
[[-1, 3], [1, 0], [0, 4]]・[[1, -2, 3], [0, 1, 2]] = [[-1, 5, 3], [1, -2, 3], [0, 4, 8]]
[[-1, 3], [1, 0], [0, 4]]・[[3, 2, -1]] -> 定義されない
[[1, -2, 3], [0, 1, 2]]・[[-1, 1, 0], [3, 0, 4]] -> 定義されない
[[1, -2, 3], [0, 1, 2]]・[[1, 0], [-2, 1], [3, 2]] = [[14, 4], [4, 5]]
[[1, -2, 3], [0, 1, 2]]・[[3], [2], [-1]] = [[-4], [0]]
[[1, -2, 3], [0, 1, 2]]・[[-1, 3], [1, 0], [0, 4]] = [[-3, 15], [1, 8]]
[[1, -2, 3], [0, 1, 2]]・[[1, -2, 3], [0, 1, 2]] -> 定義されない
[[1, -2, 3], [0, 1, 2]]・[[3, 2, -1]] -> 定義されない
[[3, 2, -1]]・[[-1, 1, 0], [3, 0, 4]] -> 定義されない
[[3, 2, -1]]・[[1, 0], [-2, 1], [3, 2]] = [[-4, 0]]
[[3, 2, -1]]・[[3], [2], [-1]] = [[14]]
[[3, 2, -1]]・[[-1, 3], [1, 0], [0, 4]] = [[-1, 5]]
[[3, 2, -1]]・[[1, -2, 3], [0, 1, 2]] -> 定義されない
[[3, 2, -1]]・[[3, 2, -1]] -> 定義されない
```

確認したところ全て正しかった。

#### おまけ 2 Rubyのブロック機能を利用した前回内容までのリファクタリング

今回までの内容で、出てきてはいたもののはっきりと理解していなかったブロックというRubyの機能を調べた。
\

ブロックは`{|引数| 処理内容または返り値}`または`do |引数| 処理内容または返り値 end`のような形であらわされ、ほかの言語で言う無名関数やラムダ式のようなものとして働く。
\
関数の引数には`&f`のように`&`をつけて定義することで取り込むことができ、関数を

```ruby
def hoge5(&f)
    puts "5 is passed to #{f} as an argument."
    p f.call(5)
end
```
というように定義した場合は

```ruby
hoge5() do |x|
    x**2
end
```

といった感じで、関数の後に続けて記述することで引数として渡すことができる。ただしこの方法で渡せるブロックは一つである。
\
なおこの方法で渡されたブロックは`ブロックが入った引数.call(ブロック引数)`または`yield(ブロック引数)`で呼び出すことができる。
\

ブロックは実際は`Proc`(プロシージャProcedure)クラスのインスタンスであり、似たようなものに`lambda`がある。
\
なお、`Proc`のインスタンスと`lambda`は`return`に対する挙動が違うといった特徴があるが、今回はブロックについてなのでここでは深く言及はしない。
\

ここまでで述べたブロックの機能を使用し、任意関数を数値積分、数値微分する関数を作成した。数値積分は第2回内容のリファクタリングとなる。

```ruby
# シンプソンの公式を利用した数値積分

def integ_bySimp(a, b, n=1000, &f)
	dx = (b - a).to_f / n
	s = 0.0
	n.times do |i|
		y_L = yield(a + i * dx) # 左端
		y_R = yield(a + (i + 1) * dx) # 右端
		y_C = yield(a + (i + 1/2.0) * dx) # 中央値
		s += ((y_L + 4*y_C + y_R) / 6.to_f ) * dx
	end
	return s
end

pi = 4 * integ_bySimp(0, 1, 10000000) do |x|
    Math::sqrt(1 - x**2)
end

p pi # => 3.1415926535853904

# 中央の値を使用する数値微分

def d(x, dx, &f)
    a = (yield(dx+x) - yield(x)) / dx
    b = (yield(x) - yield(x-dx)) / dx
    return (a+b) / 2.to_f
end

r = d(5, 10**(-5)) do |x|
    x**2 - 2
end

p r # => 10.0

r = d(5, 10**(-5)) do |x|
    x**3 - 2*x
end

p r # => 73.0000000001
```

数値微分を使用してニュートン法も再実装した。第1回内容のリファクタリングとなる。

```ruby
def newton(a, dx, acc, &f)
    res = a/2.0
    pre_res = 0
    while ((res*(10**acc)).floor) != ((pre_res*(10**acc)).floor) do
        pre_res = res
		res = pre_res - yield(pre_res, a)/d(pre_res, dx, &f).to_f
    end
    return ((res*(10**acc)).floor) / (10**acc).to_f
end

def sqrt_byN(a, acc=5)
    if a < 0 then raise ArgumentError.new(a), "複素数になります。" end
    return newton(a, 10**(-5), acc) do |x|
        x**2 - a
    end
end

puts sqrt_byN(4) # => 2.0
puts sqrt_byN(2) # => 1.41421
puts sqrt_byN(2, 10) # => 1.4142135623
puts sqrt_byN(9) # => 3.0
puts sqrt_byN(7) # => 2.64575
```

これからも共通化できる機能に目を付けてブロックを使っていきたいと思う。

## [全体の考察・感想]

第2回までに積極的に工夫を重ねてしまったために第3回では取り上げられず、若干授業とずれた内容となってしまったことは否めないが、行列計算の実装を通して配列の扱いは一通り網羅できたと思われる。
\
ここまでの回で出てきた処理は基本中の基本といえる。第4回以降も関わる内容が多いと考えられる。

## [アンケート]

- Q1. 配列が使いこなせるようになりましたか。

「プログラミングで」という意味でしたら普段使いしているのでできますが、「Rubyで」という意味ですとまだメソッドを把握しきれていないので、使いこなせているわけではないですね。。引き続き勉強したいと思います。

- Q2. 疑似コードを書くのと、Rubyに直すのと、打ち込んで動かすのとで掛かった手間の比率を教えてください。

今回は疑似コードは使用しませんでしたが、`疑似コード : Ruby : 実行 = 1 : 1 : 2`ですかね...疑似コードは実はRuby書いてから書いたりしているんで、手間ではなかったりします(笑)
\
どちらかというと、エラトステネスの篩等で、実装を考える時間が一番長かったかと思います。(これは疑似コード作成の時間には入らないかと...)

- Q3. リフレクション(今回の課題で分かったこと)・感想・要望をどうぞ。
    - [要望] `arraysum` -> 命名についてなので大した問題ではないですが、`array_sum`(`snake_case`)か`arraySum`(`camelCase`)が良いと思われます。
    - [要望] 例外処理についての記述がテキストには少ない気がします。。`begin-rescue`文とかもできれば教えていただきたかったです。(Rubyの例外処理についてはまだ知らないので)
    - [感想] 今回までは比較的課題が楽でしたが、第4回からは難しめの課題が入ってくるようですので、気を引き締めていきたいです。次回も頑張Ruby!!